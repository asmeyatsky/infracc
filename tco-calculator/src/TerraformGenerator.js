import React, { useState } from 'react';
import terraformEnhanced from './utils/terraformEnhanced';

function TerraformGenerator({ config }) {
  const [selectedTemplate, setSelectedTemplate] = useState('main');

  const generateMainTerraform = () => {
    return `# Google Cloud Landing Zone - Main Configuration
# Generated by GCP Infrastructure Modernization Accelerator

terraform {
  required_version = ">= 1.0"
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

provider "google" {
  project = var.project_id
  region  = var.region
}

# Variables
variable "project_id" {
  description = "GCP Project ID"
  type        = string
}

variable "region" {
  description = "Default GCP region"
  type        = string
  default     = "${config.networkConfig.region}"
}

variable "organization_id" {
  description = "GCP Organization ID"
  type        = string
  default     = "${config.organizationId}"
}

variable "billing_account" {
  description = "Billing Account ID"
  type        = string
  default     = "${config.billingAccountId}"
}

# Outputs
output "vpc_name" {
  description = "Name of the VPC"
  value       = module.network.vpc_name
}

output "project_ids" {
  description = "Created project IDs"
  value       = module.projects.project_ids
}
`;
  };

  const generateProjectsTerraform = () => {
    return `# Projects Configuration
# Creates GCP projects with folder structure

# Folders
${config.folders.map((folder, index) => `
resource "google_folder" "${folder.replace(/[^a-zA-Z0-9]/g, '_')}" {
  display_name = "${folder}"
  parent       = "organizations/\${var.organization_id}"
}
`).join('')}

# Projects
${config.projects.map((project, index) => `
resource "google_project" "${project.name}" {
  name            = "${project.displayName}"
  project_id      = "\${var.project_id}-${project.name}"
  billing_account = var.billing_account
  folder_id       = google_folder.${config.folders[0].replace(/[^a-zA-Z0-9]/g, '_')}.id

  labels = {
    environment = "${project.environment}"
    managed_by  = "terraform"
  }
}

resource "google_project_service" "${project.name}_apis" {
  for_each = toset([
    "compute.googleapis.com",
    "container.googleapis.com",
    "storage.googleapis.com",
    "cloudresourcemanager.googleapis.com",
    "iam.googleapis.com",
    "logging.googleapis.com",
    "monitoring.googleapis.com",
  ])

  project = google_project.${project.name}.project_id
  service = each.value

  disable_on_destroy = false
}
`).join('')}

# Module outputs
output "project_ids" {
  description = "Map of project names to IDs"
  value = {
${config.projects.map(p => `    ${p.name} = google_project.${p.name}.project_id`).join('\n')}
  }
}
`;
  };

  const generateNetworkTerraform = () => {
    return `# Network Configuration
# Creates VPC, subnets, Cloud NAT, and firewall rules

# VPC Network
resource "google_compute_network" "main" {
  name                    = "${config.networkConfig.vpcName}"
  auto_create_subnetworks = false
  project                 = var.project_id
}

# Subnets
${config.networkConfig.subnets.map((subnet, index) => `
resource "google_compute_subnetwork" "${subnet.name.replace(/-/g, '_')}" {
  name          = "${subnet.name}"
  ip_cidr_range = "${subnet.cidr}"
  region        = "${subnet.region}"
  network       = google_compute_network.main.id
  project       = var.project_id

  ${config.networkConfig.enablePrivateGoogleAccess ? `
  private_ip_google_access = true
  ` : ''}

  log_config {
    aggregation_interval = "INTERVAL_10_MIN"
    flow_sampling        = 0.5
    metadata             = "INCLUDE_ALL_METADATA"
  }
}
`).join('')}

${config.networkConfig.enableCloudRouter ? `
# Cloud Router
resource "google_compute_router" "main" {
  name    = "${config.networkConfig.vpcName}-router"
  region  = var.region
  network = google_compute_network.main.id
  project = var.project_id

  bgp {
    asn = 64514
  }
}
` : ''}

${config.networkConfig.enableCloudNAT ? `
# Cloud NAT
resource "google_compute_router_nat" "main" {
  name                               = "${config.networkConfig.vpcName}-nat"
  router                             = google_compute_router.main.name
  region                             = google_compute_router.main.region
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"
  project                            = var.project_id

  log_config {
    enable = true
    filter = "ERRORS_ONLY"
  }
}
` : ''}

# Firewall Rules
resource "google_compute_firewall" "allow_internal" {
  name    = "${config.networkConfig.vpcName}-allow-internal"
  network = google_compute_network.main.id
  project = var.project_id

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "icmp"
  }

  source_ranges = ["10.0.0.0/8"]
}

resource "google_compute_firewall" "allow_ssh" {
  name    = "${config.networkConfig.vpcName}-allow-ssh"
  network = google_compute_network.main.id
  project = var.project_id

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = ["35.235.240.0/20"]  # IAP for SSH
  target_tags   = ["allow-ssh"]
}

${config.securityConfig.requireSSL ? `
resource "google_compute_firewall" "allow_https" {
  name    = "${config.networkConfig.vpcName}-allow-https"
  network = google_compute_network.main.id
  project = var.project_id

  allow {
    protocol = "tcp"
    ports    = ["443"]
  }

  source_ranges = ["0.0.0.0/0"]
  target_tags   = ["allow-https"]
}
` : ''}

# Module outputs
output "vpc_name" {
  description = "VPC network name"
  value       = google_compute_network.main.name
}

output "vpc_id" {
  description = "VPC network ID"
  value       = google_compute_network.main.id
}

output "subnet_ids" {
  description = "Map of subnet names to IDs"
  value = {
${config.networkConfig.subnets.map(s => `    ${s.name.replace(/-/g, '_')} = google_compute_subnetwork.${s.name.replace(/-/g, '_')}.id`).join('\n')}
  }
}
`;
  };

  const generateComputeTerraform = () => {
    return `# Compute Resources Configuration
# GKE clusters and Compute Engine instances

${config.computeConfig.enableGKE ? `
# GKE Cluster
resource "google_container_cluster" "primary" {
  name     = "primary-gke-cluster"
  location = var.region
  project  = var.project_id

  # Remove default node pool
  remove_default_node_pool = true
  initial_node_count       = 1

  network    = google_compute_network.main.id
  subnetwork = google_compute_subnetwork.${config.networkConfig.subnets[0].name.replace(/-/g, '_')}.id

  # Enable autopilot or standard mode
  workload_identity_config {
    workload_pool = "\${var.project_id}.svc.id.goog"
  }

  ip_allocation_policy {
    cluster_ipv4_cidr_block  = "/16"
    services_ipv4_cidr_block = "/22"
  }

  private_cluster_config {
    enable_private_nodes    = true
    enable_private_endpoint = false
    master_ipv4_cidr_block  = "172.16.0.0/28"
  }

  master_authorized_networks_config {
    cidr_blocks {
      cidr_block   = "0.0.0.0/0"
      display_name = "All networks"
    }
  }

  addons_config {
    horizontal_pod_autoscaling {
      disabled = false
    }
    http_load_balancing {
      disabled = false
    }
    network_policy_config {
      disabled = false
    }
  }

  release_channel {
    channel = "STABLE"
  }

  ${config.observabilityConfig.enableCloudMonitoring ? `
  logging_config {
    enable_components = ["SYSTEM_COMPONENTS", "WORKLOADS"]
  }

  monitoring_config {
    enable_components = ["SYSTEM_COMPONENTS"]
    managed_prometheus {
      enabled = true
    }
  }
  ` : ''}
}

# GKE Node Pool
resource "google_container_node_pool" "primary_nodes" {
  name       = "primary-node-pool"
  location   = var.region
  cluster    = google_container_cluster.primary.name
  node_count = ${config.computeConfig.gkeNodesPerPool}
  project    = var.project_id

  node_config {
    machine_type = "${config.computeConfig.defaultMachineType}"
    disk_size_gb = 100
    disk_type    = "pd-standard"

    oauth_scopes = [
      "https://www.googleapis.com/auth/cloud-platform"
    ]

    labels = {
      environment = "production"
    }

    tags = ["gke-node"]

    workload_metadata_config {
      mode = "GKE_METADATA"
    }

    shielded_instance_config {
      enable_secure_boot          = true
      enable_integrity_monitoring = true
    }
  }

  management {
    auto_repair  = true
    auto_upgrade = true
  }

  autoscaling {
    min_node_count = 1
    max_node_count = 10
  }
}
` : ''}

${config.computeConfig.enableComputeEngine ? `
# Compute Engine Instance Template
resource "google_compute_instance_template" "default" {
  name_prefix  = "default-template-"
  machine_type = "${config.computeConfig.defaultMachineType}"
  project      = var.project_id

  disk {
    source_image = "debian-cloud/debian-11"
    auto_delete  = true
    boot         = true
    disk_size_gb = 100
  }

  network_interface {
    network    = google_compute_network.main.id
    subnetwork = google_compute_subnetwork.${config.networkConfig.subnets[0].name.replace(/-/g, '_')}.id

    access_config {
      # Ephemeral external IP
    }
  }

  metadata = {
    enable-oslogin = "true"
  }

  labels = {
    environment = "production"
    managed_by  = "terraform"
  }

  shielded_instance_config {
    enable_secure_boot          = true
    enable_vtpm                 = true
    enable_integrity_monitoring = true
  }

  lifecycle {
    create_before_destroy = true
  }
}
` : ''}

# Outputs
${config.computeConfig.enableGKE ? `
output "gke_cluster_name" {
  description = "GKE cluster name"
  value       = google_container_cluster.primary.name
}

output "gke_cluster_endpoint" {
  description = "GKE cluster endpoint"
  value       = google_container_cluster.primary.endpoint
  sensitive   = true
}
` : ''}
`;
  };

  const generateStorageTerraform = () => {
    return `# Storage & Database Configuration

${config.storageConfig.enableCloudStorage ? `
# Cloud Storage Buckets
${config.storageConfig.storageBuckets.map((bucket, index) => `
resource "google_storage_bucket" "${bucket.replace(/[^a-zA-Z0-9]/g, '_')}" {
  name     = "\${var.project_id}-${bucket}"
  location = var.region
  project  = var.project_id

  uniform_bucket_level_access = true

  versioning {
    enabled = true
  }

  lifecycle_rule {
    condition {
      age = 90
    }
    action {
      type = "Delete"
    }
  }

  ${config.securityConfig.requireSSL ? `
  encryption {
    default_kms_key_name = google_kms_crypto_key.storage_key.id
  }
  ` : ''}

  labels = {
    environment = "production"
    purpose     = "${bucket}"
  }
}
`).join('')}
` : ''}

${config.storageConfig.enableCloudSQL ? `
# Cloud SQL Instance
resource "google_sql_database_instance" "main" {
  name             = "main-sql-instance"
  database_version = "${config.storageConfig.sqlVersion}"
  region           = var.region
  project          = var.project_id

  settings {
    tier              = "db-custom-2-7680"
    availability_type = "REGIONAL"
    disk_size         = 100
    disk_type         = "PD_SSD"

    backup_configuration {
      enabled                        = true
      point_in_time_recovery_enabled = true
      start_time                     = "03:00"
      transaction_log_retention_days = 7
      backup_retention_settings {
        retained_backups = 30
      }
    }

    ip_configuration {
      ipv4_enabled    = false
      private_network = google_compute_network.main.id
      ${config.securityConfig.requireSSL ? `
      require_ssl = true
      ` : ''}
    }

    database_flags {
      name  = "log_checkpoints"
      value = "on"
    }

    insights_config {
      query_insights_enabled  = true
      query_string_length     = 1024
      record_application_tags = true
    }

    maintenance_window {
      day          = 7
      hour         = 3
      update_track = "stable"
    }
  }

  deletion_protection = true
}

resource "google_sql_database" "main" {
  name     = "main-database"
  instance = google_sql_database_instance.main.name
  project  = var.project_id
}
` : ''}

${config.storageConfig.enableFirestore ? `
# Firestore Database
resource "google_firestore_database" "main" {
  project     = var.project_id
  name        = "(default)"
  location_id = var.region
  type        = "FIRESTORE_NATIVE"

  concurrency_mode = "OPTIMISTIC"
}
` : ''}

${config.securityConfig.requireSSL ? `
# KMS Key Ring for encryption
resource "google_kms_key_ring" "main" {
  name     = "main-keyring"
  location = var.region
  project  = var.project_id
}

resource "google_kms_crypto_key" "storage_key" {
  name     = "storage-key"
  key_ring = google_kms_key_ring.main.id

  rotation_period = "7776000s"  # 90 days

  lifecycle {
    prevent_destroy = true
  }
}
` : ''}

# Outputs
${config.storageConfig.enableCloudStorage ? `
output "storage_buckets" {
  description = "Storage bucket names"
  value = [
${config.storageConfig.storageBuckets.map(b => `    google_storage_bucket.${b.replace(/[^a-zA-Z0-9]/g, '_')}.name`).join(',\n')}
  ]
}
` : ''}

${config.storageConfig.enableCloudSQL ? `
output "sql_instance_connection_name" {
  description = "Cloud SQL instance connection name"
  value       = google_sql_database_instance.main.connection_name
}
` : ''}
`;
  };

  const generateMonitoringTerraform = () => {
    return `# Monitoring & Logging Configuration

${config.observabilityConfig.enableCloudMonitoring ? `
# Uptime Check
resource "google_monitoring_uptime_check_config" "https" {
  display_name = "HTTPS Uptime Check"
  timeout      = "10s"
  period       = "60s"
  project      = var.project_id

  http_check {
    path         = "/"
    port         = "443"
    use_ssl      = true
    validate_ssl = true
  }

  monitored_resource {
    type = "uptime_url"
    labels = {
      project_id = var.project_id
      host       = "example.com"
    }
  }
}

# Alert Policy for High CPU
resource "google_monitoring_alert_policy" "high_cpu" {
  display_name = "High CPU Usage"
  combiner     = "OR"
  project      = var.project_id

  conditions {
    display_name = "CPU usage above 80%"

    condition_threshold {
      filter          = "resource.type = \\"gce_instance\\" AND metric.type = \\"compute.googleapis.com/instance/cpu/utilization\\""
      duration        = "300s"
      comparison      = "COMPARISON_GT"
      threshold_value = 0.8

      aggregations {
        alignment_period   = "60s"
        per_series_aligner = "ALIGN_MEAN"
      }
    }
  }

  notification_channels = []

  alert_strategy {
    auto_close = "604800s"
  }
}
` : ''}

${config.observabilityConfig.enableCloudLogging ? `
# Log Bucket
resource "google_logging_project_bucket_config" "main" {
  project        = var.project_id
  location       = "global"
  retention_days = ${config.observabilityConfig.logRetentionDays}
  bucket_id      = "_Default"
}

# Log Sink to Cloud Storage
resource "google_logging_project_sink" "storage_sink" {
  name        = "storage-sink"
  destination = "storage.googleapis.com/\${google_storage_bucket.logs.name}"
  project     = var.project_id

  filter = "severity >= WARNING"

  unique_writer_identity = true
}

resource "google_storage_bucket" "logs" {
  name     = "\${var.project_id}-logs"
  location = var.region
  project  = var.project_id

  uniform_bucket_level_access = true

  lifecycle_rule {
    condition {
      age = ${config.observabilityConfig.logRetentionDays}
    }
    action {
      type = "Delete"
    }
  }
}

resource "google_storage_bucket_iam_member" "log_writer" {
  bucket = google_storage_bucket.logs.name
  role   = "roles/storage.objectCreator"
  member = google_logging_project_sink.storage_sink.writer_identity
}
` : ''}

# Outputs
output "log_bucket" {
  description = "Log storage bucket"
  value       = google_storage_bucket.logs.name
}
`;
  };

  const generateSecurityTerraform = () => {
    return `# Security & IAM Configuration

${config.securityConfig.enableOrgPolicies ? `
# Organization Policies
resource "google_org_policy_policy" "require_os_login" {
  name   = "projects/\${var.project_id}/policies/compute.requireOsLogin"
  parent = "projects/\${var.project_id}"

  spec {
    rules {
      enforce = "TRUE"
    }
  }
}

resource "google_org_policy_policy" "skip_default_network" {
  name   = "projects/\${var.project_id}/policies/compute.skipDefaultNetworkCreation"
  parent = "projects/\${var.project_id}"

  spec {
    rules {
      enforce = "TRUE"
    }
  }
}

${config.securityConfig.requireSSL ? `
resource "google_org_policy_policy" "ssl_policy" {
  name   = "projects/\${var.project_id}/policies/compute.sslPolicies"
  parent = "projects/\${var.project_id}"

  spec {
    rules {
      enforce = "TRUE"
    }
  }
}
` : ''}
` : ''}

# Service Accounts
resource "google_service_account" "gke_nodes" {
  account_id   = "gke-nodes"
  display_name = "GKE Nodes Service Account"
  project      = var.project_id
}

resource "google_project_iam_member" "gke_nodes_log_writer" {
  project = var.project_id
  role    = "roles/logging.logWriter"
  member  = "serviceAccount:\${google_service_account.gke_nodes.email}"
}

resource "google_project_iam_member" "gke_nodes_metric_writer" {
  project = var.project_id
  role    = "roles/monitoring.metricWriter"
  member  = "serviceAccount:\${google_service_account.gke_nodes.email}"
}

resource "google_project_iam_member" "gke_nodes_monitoring_viewer" {
  project = var.project_id
  role    = "roles/monitoring.viewer"
  member  = "serviceAccount:\${google_service_account.gke_nodes.email}"
}

# Custom IAM Roles
resource "google_project_iam_custom_role" "deployer" {
  role_id     = "deployer"
  title       = "Deployer"
  description = "Role for deployment automation"
  project     = var.project_id

  permissions = [
    "compute.instances.create",
    "compute.instances.delete",
    "compute.instances.get",
    "compute.instances.list",
    "compute.instances.setMetadata",
    "compute.instances.setServiceAccount",
    "storage.buckets.get",
    "storage.objects.create",
    "storage.objects.delete",
  ]
}

# Outputs
output "gke_service_account_email" {
  description = "GKE nodes service account email"
  value       = google_service_account.gke_nodes.email
}
`;
  };

  const templates = {
    main: {
      name: 'main.tf',
      title: 'Main Configuration',
      icon: 'üìÑ',
      generator: generateMainTerraform,
    },
    projects: {
      name: 'projects.tf',
      title: 'Projects & Organization',
      icon: 'üìä',
      generator: generateProjectsTerraform,
    },
    network: {
      name: 'network.tf',
      title: 'Network & VPC',
      icon: 'üåê',
      generator: generateNetworkTerraform,
    },
    compute: {
      name: 'compute.tf',
      title: 'Compute Resources',
      icon: 'üíª',
      generator: generateComputeTerraform,
    },
    storage: {
      name: 'storage.tf',
      title: 'Storage & Databases',
      icon: 'üíæ',
      generator: generateStorageTerraform,
    },
    monitoring: {
      name: 'monitoring.tf',
      title: 'Monitoring & Logging',
      icon: 'üìä',
      generator: generateMonitoringTerraform,
    },
    security: {
      name: 'security.tf',
      title: 'Security & IAM',
      icon: 'üîí',
      generator: generateSecurityTerraform,
    },
    // Enhanced Terraform files
    tfvars: {
      name: 'terraform.tfvars',
      title: 'Variables (tfvars)',
      icon: '‚öôÔ∏è',
      generator: () => terraformEnhanced.generateTfvars(config),
    },
    variables: {
      name: 'variables.tf',
      title: 'Variable Definitions',
      icon: 'üìù',
      generator: terraformEnhanced.generateVariablesTf,
    },
    outputs: {
      name: 'outputs.tf',
      title: 'Outputs',
      icon: 'üì§',
      generator: terraformEnhanced.generateOutputsTf,
    },
    backend: {
      name: 'backend.tf',
      title: 'Backend Config',
      icon: '‚òÅÔ∏è',
      generator: () => terraformEnhanced.generateBackendTf('terraform-state-' + (config.organizationId || 'bucket')),
    },
    versions: {
      name: 'versions.tf',
      title: 'Version Constraints',
      icon: 'üîñ',
      generator: terraformEnhanced.generateVersionsTf,
    },
    modular: {
      name: 'main-modular.tf',
      title: 'Modular Main (Advanced)',
      icon: 'üß©',
      generator: terraformEnhanced.generateModularMainTf,
    },
    readme: {
      name: 'README.md',
      title: 'Documentation',
      icon: 'üìñ',
      generator: terraformEnhanced.generateTerraformReadme,
    },
  };

  const downloadTemplate = (templateKey) => {
    const template = templates[templateKey];
    const content = template.generator();
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = template.name;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  const downloadAll = () => {
    Object.keys(templates).forEach((key) => {
      setTimeout(() => downloadTemplate(key), 100 * Object.keys(templates).indexOf(key));
    });
  };

  const copyToClipboard = (templateKey) => {
    const template = templates[templateKey];
    const content = template.generator();
    navigator.clipboard.writeText(content).then(() => {
      alert(`${template.name} copied to clipboard!`);
    });
  };

  return (
    <div className="card mb-4">
      <div className="card-header bg-success text-white">
        <h3 className="mb-0">üì¶ Terraform Template Generator</h3>
        <small>Generated Infrastructure as Code for your landing zone</small>
      </div>
      <div className="card-body">
        <div className="alert alert-success">
          <strong>‚úì Configuration Complete!</strong> Your Terraform templates are ready to download.
          These templates follow Google Cloud best practices and are production-ready.
        </div>

        {/* Template Selector */}
        <div className="row mb-4">
          <div className="col-12">
            <h5 className="mb-3">Available Templates</h5>
            <div className="btn-group flex-wrap" role="group">
              {Object.entries(templates).map(([key, template]) => (
                <button
                  key={key}
                  type="button"
                  className={`btn ${selectedTemplate === key ? 'btn-success' : 'btn-outline-success'}`}
                  onClick={() => setSelectedTemplate(key)}
                >
                  {template.icon} {template.title}
                </button>
              ))}
            </div>
          </div>
        </div>

        {/* Template Preview */}
        <div className="row mb-4">
          <div className="col-12">
            <div className="d-flex justify-content-between align-items-center mb-2">
              <h6 className="mb-0">
                {templates[selectedTemplate].icon} {templates[selectedTemplate].name}
              </h6>
              <div>
                <button
                  className="btn btn-sm btn-outline-secondary me-2"
                  onClick={() => copyToClipboard(selectedTemplate)}
                >
                  üìã Copy
                </button>
                <button
                  className="btn btn-sm btn-success"
                  onClick={() => downloadTemplate(selectedTemplate)}
                >
                  ‚¨áÔ∏è Download
                </button>
              </div>
            </div>
            <pre
              className="bg-dark text-light p-3 rounded"
              style={{ maxHeight: '500px', overflow: 'auto', fontSize: '0.85rem' }}
            >
              <code>{templates[selectedTemplate].generator()}</code>
            </pre>
          </div>
        </div>

        {/* Quick Actions */}
        <div className="row">
          <div className="col-12">
            <h5 className="mb-3">Quick Actions</h5>
            <div className="d-grid gap-2">
              <button className="btn btn-lg btn-success" onClick={downloadAll}>
                üì¶ Download All Templates (ZIP)
              </button>
            </div>

            <div className="alert alert-info mt-3">
              <strong>Next Steps:</strong>
              <ol className="mb-0 mt-2">
                <li>Download the Terraform templates</li>
                <li>Review and customize variables in <code>main.tf</code></li>
                <li>Initialize Terraform: <code>terraform init</code></li>
                <li>Plan your deployment: <code>terraform plan</code></li>
                <li>Apply the configuration: <code>terraform apply</code></li>
              </ol>
            </div>
          </div>
        </div>

        {/* Template Summary */}
        <div className="row mt-4">
          <div className="col-12">
            <h5 className="mb-3">Template Summary</h5>
            <div className="table-responsive">
              <table className="table table-sm">
                <thead>
                  <tr>
                    <th>File</th>
                    <th>Description</th>
                    <th>Resources</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>main.tf</code></td>
                    <td>Provider configuration and variables</td>
                    <td>Core setup</td>
                  </tr>
                  <tr>
                    <td><code>projects.tf</code></td>
                    <td>GCP projects and folders</td>
                    <td>{config.projects.length} projects, {config.folders.length} folders</td>
                  </tr>
                  <tr>
                    <td><code>network.tf</code></td>
                    <td>VPC, subnets, and networking</td>
                    <td>1 VPC, {config.networkConfig.subnets.length} subnets</td>
                  </tr>
                  <tr>
                    <td><code>compute.tf</code></td>
                    <td>GKE and Compute Engine</td>
                    <td>
                      {config.computeConfig.enableGKE ? '1 GKE cluster' : ''}
                      {config.computeConfig.enableGKE && config.computeConfig.enableComputeEngine ? ', ' : ''}
                      {config.computeConfig.enableComputeEngine ? 'VM templates' : ''}
                    </td>
                  </tr>
                  <tr>
                    <td><code>storage.tf</code></td>
                    <td>Storage buckets and databases</td>
                    <td>
                      {config.storageConfig.enableCloudStorage ? `${config.storageConfig.storageBuckets.length} buckets` : ''}
                      {config.storageConfig.enableCloudSQL ? ', Cloud SQL' : ''}
                    </td>
                  </tr>
                  <tr>
                    <td><code>monitoring.tf</code></td>
                    <td>Logging and monitoring</td>
                    <td>Alerts, logs, uptime checks</td>
                  </tr>
                  <tr>
                    <td><code>security.tf</code></td>
                    <td>IAM roles and policies</td>
                    <td>Service accounts, org policies</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default TerraformGenerator;
